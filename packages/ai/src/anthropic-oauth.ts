/**
 * Anthropic adapter factory with OAuth token support.
 *
 * Creates an Anthropic text adapter using an OAuth access token
 * instead of an API key. Requires the `anthropic-beta` header
 * for OAuth token authentication.
 *
 * Also provides OAuth flow helpers (PKCE authorize, exchange, API key creation,
 * refresh) used by auth routes.
 */

import {
	createAnthropicChat,
	type AnthropicChatModel
} from '@tanstack/ai-anthropic'
import type { AnyTextAdapter } from '@tanstack/ai'
import type { NormalizedOAuthCredential } from './credentials'

// ── Constants ────────────────────────────────────────────────────────────────

const CLIENT_ID = '9d1c250a-e61b-44d9-88ed-5944d1962f5e'
const REDIRECT_URI =
	'https://console.anthropic.com/oauth/code/callback'
const TOKEN_URL =
	'https://console.anthropic.com/v1/oauth/token'
const SCOPES =
	'org:create_api_key user:profile user:inference'
const CREATE_KEY_URL =
	'https://api.anthropic.com/api/oauth/claude_cli/create_api_key'

// Required beta header for OAuth token authentication
const OAUTH_BETA_HEADER =
	'claude-code-20250219,oauth-2025-04-20'

export type OAuthMode = 'max' | 'console'

// ── PKCE ─────────────────────────────────────────────────────────────────────

async function generatePKCE(): Promise<{
	verifier: string
	challenge: string
}> {
	const array = new Uint8Array(32)
	crypto.getRandomValues(array)
	const verifier = base64url(array)
	const hash = await crypto.subtle.digest(
		'SHA-256',
		new TextEncoder().encode(verifier)
	)
	const challenge = base64url(new Uint8Array(hash))
	return { verifier, challenge }
}

function base64url(bytes: Uint8Array): string {
	let binary = ''
	for (const b of bytes) binary += String.fromCharCode(b)
	return btoa(binary)
		.replace(/\+/g, '-')
		.replace(/\//g, '_')
		.replace(/=+$/, '')
}

// ── Adapter factories ────────────────────────────────────────────────────────

/**
 * Create an Anthropic adapter using an OAuth access token.
 */
export function anthropicOAuth(
	model: string,
	accessToken: string
): AnyTextAdapter {
	return createAnthropicChat(
		model as AnthropicChatModel,
		'',
		{
			authToken: accessToken,
			defaultHeaders: {
				'anthropic-beta': OAUTH_BETA_HEADER
			}
		} as Record<string, unknown>
	)
}

// ── OAuth flow helpers ───────────────────────────────────────────────────────

export interface OAuthAuthorizeResult {
	verifier: string
	state: string
	url: string
}

/**
 * Generate a PKCE-protected authorize URL for Anthropic OAuth.
 */
export async function oauthAuthorize(
	mode: OAuthMode
): Promise<OAuthAuthorizeResult> {
	const pkce = await generatePKCE()

	// Generate a separate random state value for CSRF protection.
	// Keeping it distinct from the PKCE verifier avoids leaking the
	// PKCE secret through the OAuth state parameter.
	const stateBytes = new Uint8Array(16)
	crypto.getRandomValues(stateBytes)
	const state = base64url(stateBytes)

	const base =
		mode === 'console'
			? 'https://console.anthropic.com'
			: 'https://claude.ai'

	const url = new URL(`${base}/oauth/authorize`)
	url.searchParams.set('code', 'true')
	url.searchParams.set('client_id', CLIENT_ID)
	url.searchParams.set('response_type', 'code')
	url.searchParams.set('redirect_uri', REDIRECT_URI)
	url.searchParams.set('scope', SCOPES)
	url.searchParams.set('code_challenge', pkce.challenge)
	url.searchParams.set('code_challenge_method', 'S256')
	url.searchParams.set('state', state)

	return {
		verifier: pkce.verifier,
		state,
		url: url.toString()
	}
}

export interface OAuthTokens {
	accessToken: string
	refreshToken: string
	expiresAt: number
}

/**
 * Exchange a callback code for tokens.
 * Callback format from Anthropic: `code#state`
 *
 * Note: client-side state verification is intentionally omitted.
 * The state value is generated by the same server process that initiates
 * the flow and is passed back through the CLI — there is no cross-origin
 * risk. Anthropic's authorization server validates the state during the
 * token exchange (it is included in the POST body as part of the callback
 * code), providing the server-side CSRF protection.
 */
export async function oauthExchange(
	callbackCode: string,
	verifier: string
): Promise<
	| { ok: true; tokens: OAuthTokens }
	| { ok: false; error: string }
> {
	const splits = callbackCode.trim().split('#')
	const code = splits[0]
	const state = splits[1] ?? ''

	try {
		const res = await fetch(TOKEN_URL, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({
				code,
				state,
				grant_type: 'authorization_code',
				client_id: CLIENT_ID,
				redirect_uri: REDIRECT_URI,
				code_verifier: verifier
			})
		})

		if (!res.ok) {
			const body = await res.text()
			return {
				ok: false,
				error: `Token exchange failed (${res.status}): ${body}`
			}
		}

		const json = (await res.json()) as {
			access_token: string
			refresh_token: string
			expires_in: number
		}

		return {
			ok: true,
			tokens: {
				accessToken: json.access_token,
				refreshToken: json.refresh_token,
				expiresAt: Date.now() + json.expires_in * 1000
			}
		}
	} catch (err) {
		return {
			ok: false,
			error: `Network error: ${err instanceof Error ? err.message : String(err)}`
		}
	}
}

/**
 * Create a permanent API key from an OAuth access token (console flow).
 */
export async function oauthCreateApiKey(
	accessToken: string
): Promise<
	{ ok: true; key: string } | { ok: false; error: string }
> {
	try {
		const res = await fetch(CREATE_KEY_URL, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				authorization: `Bearer ${accessToken}`
			}
		})

		if (!res.ok) {
			const body = await res.text()
			return {
				ok: false,
				error: `API key creation failed (${res.status}): ${body}`
			}
		}

		const json = (await res.json()) as {
			raw_key: string
		}
		return { ok: true, key: json.raw_key }
	} catch (err) {
		return {
			ok: false,
			error: `Network error: ${err instanceof Error ? err.message : String(err)}`
		}
	}
}

/**
 * Convert OAuthTokens to the normalized credential for storage.
 */
export function tokensToCredential(
	tokens: OAuthTokens
): NormalizedOAuthCredential {
	return {
		type: 'oauth',
		access: tokens.accessToken,
		refresh: tokens.refreshToken,
		expires: tokens.expiresAt
	}
}

// ── Token refresh ────────────────────────────────────────────────────────────

/**
 * Refresh an OAuth token using the refresh_token grant.
 * Accepts both legacy OAuthCredential and NormalizedOAuthCredential.
 * Returns a NormalizedOAuthCredential, or null if refresh fails.
 *
 * Does NOT save to disk — caller is responsible for persisting.
 */
export async function refreshNormalizedOAuthToken(
	refresh: string
): Promise<NormalizedOAuthCredential | null> {
	try {
		const res = await fetch(TOKEN_URL, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({
				grant_type: 'refresh_token',
				client_id: CLIENT_ID,
				refresh_token: refresh
			})
		})

		if (!res.ok) {
			const body = await res.text().catch(() => '')
			console.warn(
				`[anthropic-oauth] token refresh failed (${res.status}): ${body.slice(0, 200)}`
			)
			return null
		}

		const json = (await res.json()) as {
			access_token: string
			refresh_token: string
			expires_in: number
		}

		return {
			type: 'oauth',
			access: json.access_token,
			refresh: json.refresh_token,
			expires: Date.now() + json.expires_in * 1000
		}
	} catch (err) {
		console.warn(
			`[anthropic-oauth] token refresh error: ${err instanceof Error ? err.message : String(err)}`
		)
		return null
	}
}
